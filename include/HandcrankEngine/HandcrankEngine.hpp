// Handcrank Engine - https://handcrankengine.com/
//
// ░█░█░█▀█░█▀█░█▀▄░█▀▀░█▀▄░█▀█░█▀█░█░█░░░█▀▀░█▀█░█▀▀░▀█▀░█▀█░█▀▀
// ░█▀█░█▀█░█░█░█░█░█░░░█▀▄░█▀█░█░█░█▀▄░░░█▀▀░█░█░█░█░░█░░█░█░█▀▀
// ░▀░▀░▀░▀░▀░▀░▀▀░░▀▀▀░▀░▀░▀░▀░▀░▀░▀░▀░░░▀▀▀░▀░▀░▀▀▀░▀▀▀░▀░▀░▀▀▀
//
// Copyright (c) Scott Doxey. All Rights Reserved. Licensed under the MIT
// License. See LICENSE in the project root for license information.

// #define HANDCRANK_ENGINE_DEBUG 1

#pragma once

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

#define HANDCRANK_ENGINE_VERSION_MAJOR 0
#define HANDCRANK_ENGINE_VERSION_MINOR 0
#define HANDCRANK_ENGINE_VERSION_PATCH 0

#include <memory>

#include <SDL.h>
#include <SDL_ttf.h>

#include "AudioCache.hpp"
#include "FontCache.hpp"
#include "TextureCache.hpp"

#include "InputHandler.hpp"
#include "Utilities.hpp"

namespace HandcrankEngine
{

inline const int MAX_R = 255;
inline const int MAX_G = 255;
inline const int MAX_B = 255;
inline const int MAX_ALPHA = 255;

inline const SDL_Color DEFAULT_COLOR = {MAX_R, MAX_G, MAX_B, MAX_ALPHA};

inline const double MILLISECONDS = 1000.0;

inline const double DEFAULT_FRAME_RATE = 60;
inline const int DEFAULT_WINDOW_WIDTH = 800;
inline const int DEFAULT_WINDOW_HEIGHT = 600;
inline const float DEFAULT_RECT_WIDTH = 100;
inline const float DEFAULT_RECT_HEIGHT = 100;

class Game;
class RenderObject;

enum class RectAnchor : uint8_t
{
    TOP = 0x01,
    LEFT = 0x02,
    BOTTOM = 0x04,
    RIGHT = 0x08,
    VCENTER = 0x10,
    HCENTER = 0x20,
};

[[nodiscard]] inline auto operator|(RectAnchor a, RectAnchor b) -> RectAnchor
{
    return static_cast<RectAnchor>(static_cast<uint8_t>(a) |
                                   static_cast<uint8_t>(b));
}

[[nodiscard]] inline auto operator&(RectAnchor a, RectAnchor b) -> RectAnchor
{
    return static_cast<RectAnchor>(static_cast<uint8_t>(a) &
                                   static_cast<uint8_t>(b));
}

inline std::shared_ptr<SDL_Texture> debugRectTexture;

class Game : public InputHandler
{
  private:
    SDL_Window *window = nullptr;
    SDL_Renderer *renderer = nullptr;

    SDL_Rect viewport{};
    SDL_FRect viewportf{};

    SDL_Color clearColor{0, 0, 0, MAX_ALPHA};

    bool quit = false;

    bool fullscreen = false;

    std::vector<std::shared_ptr<RenderObject>> children;
    std::vector<std::shared_ptr<RenderObject>> childrenBuffer;

    std::vector<std::shared_ptr<RenderObject>> colliders;

    double elapsedTime = 0;
    double deltaTime = 0;
    double fixedUpdateDeltaTime = 0;

    double frameRate = DEFAULT_FRAME_RATE;

    Uint64 previousFrameStart = 0;
    double fps = 0;
    int framesThisSecond = 0;

    const double fixedFrameTime = 0.02;

    int width = DEFAULT_WINDOW_WIDTH;
    int height = DEFAULT_WINDOW_HEIGHT;

    bool focused = false;

#ifdef HANDCRANK_ENGINE_DEBUG
    bool debug = false;
#endif

  public:
    inline Game();
    virtual inline ~Game();

    inline void AddChildObject(const std::shared_ptr<RenderObject> &child);

    template <typename T>
    [[nodiscard]] inline auto GetChildrenByType(bool nested = false)
        -> std::vector<std::shared_ptr<T>>;
    template <typename T>
    [[nodiscard]] inline auto GetChildByType(bool nested = false)
        -> std::shared_ptr<T>;
    [[nodiscard]] inline auto GetChildCount() -> int;

    inline void AddCollider(const std::shared_ptr<RenderObject> &collider);

    [[nodiscard]] inline auto GetWindow() -> SDL_Window *;
    [[nodiscard]] inline auto GetRenderer() -> SDL_Renderer *;
    [[nodiscard]] inline auto GetViewport() const -> const SDL_FRect &;

    inline auto SwitchToFullscreen() -> bool;
    inline auto SwitchToWindowedMode() -> bool;
    [[nodiscard]] inline auto IsFullscreen() const -> bool;

    inline auto Setup() -> bool;

    inline void SetScreenSize(int _width, int _height);

    inline void RecalculateScreenSize();

    inline void SetTitle(const char *name);

    inline void SetClearColor(SDL_Color color);

    [[nodiscard]] inline auto GetWidth() const -> int;
    [[nodiscard]] inline auto GetHeight() const -> int;

    [[nodiscard]] inline auto HasFocus() const -> bool;

    [[nodiscard]] inline auto GetElapsedTime() const -> double;

    [[nodiscard]] inline auto GetFrameRate() const -> double;

    [[nodiscard]] inline auto GetFPS() const -> double;

    inline void SetFrameRate(double frameRate);

    [[nodiscard]] inline auto GetQuit() const -> bool;

    [[nodiscard]] inline auto Run() -> int;

    inline void Loop();

#ifdef __EMSCRIPTEN__
    static inline void StaticLoop(void *userData);
#endif

    inline void HandleInput();

    inline void CalculateDeltaTime();

    inline void PopulateChildrenBuffer();

    inline void Update();
    inline void FixedUpdate();

    inline void Render();

    inline void ResolveCollisions();

    inline void DestroyChildObjects();

    inline void Quit();

#ifdef HANDCRANK_ENGINE_DEBUG
    inline void ToggleDebug(bool state);
    inline void ToggleDebug();
    [[nodiscard]] inline auto IsDebug() const -> bool;
#endif
};

class RenderObject : public std::enable_shared_from_this<RenderObject>
{
  private:
    SDL_FRect rect = SDL_FRect();

    SDL_FRect transformedRect = SDL_FRect();
    bool transformedRectIsDirty = true;

    SDL_FRect boundingBox = SDL_FRect();
    bool boundingBoxIsDirty = true;

  protected:
    inline static unsigned int count = 0;

    int index;

    std::string name;

    std::string tag;

    RectAnchor anchor = RectAnchor::TOP | RectAnchor::LEFT;

    float scale = 1;

    bool hasStarted = false;

    bool isEnabled = true;

    bool isCollisionEnabled = false;

    bool isMarkedForDestroy = false;

    bool isInputHovered = false;
    bool isInputActive = false;

    std::vector<std::shared_ptr<RenderObject>> children;
    std::vector<std::shared_ptr<RenderObject>> childrenBuffer;

  public:
    Game *game = nullptr;

    RenderObject *parent = nullptr;

    int z = 0;

    inline RenderObject();
    inline RenderObject(float x, float y);
    inline RenderObject(float x, float y, float w, float h);

    virtual inline ~RenderObject();

    inline void Enable();
    inline void Disable();
    [[nodiscard]] inline auto IsEnabled() const -> bool;

    [[nodiscard]] inline auto IsCollisionEnabled() const -> bool;

    [[nodiscard]] inline auto GetIndex() const -> int;

    [[nodiscard]] inline auto GetName() const -> std::string;
    inline void SetName(const std::string &name);

    [[nodiscard]] inline auto GetTag() const -> std::string;
    inline void SetTag(const std::string &tag);

    [[nodiscard]] inline auto GetClassName() const -> std::string;

    [[nodiscard]] inline auto ShowInHierarchy() const -> std::string;

    inline void AddChildObject(const std::shared_ptr<RenderObject> &child);

    template <typename T>
    [[nodiscard]] inline auto GetChildrenByType(bool nested = false)
        -> std::vector<std::shared_ptr<T>>;
    template <typename T>
    [[nodiscard]] inline auto GetChildByType(bool nested = false)
        -> std::shared_ptr<T>;
    [[nodiscard]] inline auto GetChildCount() -> int;

    inline void PopulateChildrenBuffer();

    virtual inline void Start();
    virtual inline void Update(double deltaTime);
    virtual inline void FixedUpdate(double deltaTime);

    virtual inline void OnMouseOver();
    virtual inline void OnMouseOut();
    virtual inline void OnMouseDown();
    virtual inline void OnMouseUp();

    virtual inline void OnCollision(const std::shared_ptr<RenderObject> &other);

    virtual inline void InternalUpdate(double deltaTime);
    virtual inline void InternalFixedUpdate(double fixedDeltaTime);

    virtual inline void OnDestroy();

    [[nodiscard]] inline auto GetRect() const -> const SDL_FRect &;
    inline void SetRect(const SDL_FRect &rect);
    inline void SetRect(float x, float y, float w, float h);
    inline void SetPosition(float x, float y);
    inline void SetDimension(float w, float h);

    [[nodiscard]] inline auto GetAnchor() const -> const RectAnchor &;
    inline void SetAnchor(RectAnchor anchor);

    [[nodiscard]] inline auto GetScale() const -> float;
    inline void SetScale(float scale);

    [[nodiscard]] inline auto GetTransformedRect() -> SDL_FRect;
    inline void SetTransformedRect();

    inline void SetTransformedRectAsDirty();

    [[nodiscard]] inline auto GetBoundingBox() -> SDL_FRect;
    inline void SetBoundingBox();

    inline void SetBoundingBoxAsDirty();

    inline void EnableCollider();
    inline void DisableCollider();

    [[nodiscard]] inline auto CanRender() -> bool;
    virtual inline void Render(SDL_Renderer *renderer);

    [[nodiscard]] inline auto
    CheckCollisionAABB(const std::shared_ptr<RenderObject> &otherRenderObject)
        -> bool;

    inline void DestroyChildObjects();

    [[nodiscard]] inline auto HasBeenMarkedForDestroy() const -> bool;

    inline void Destroy();
};

inline Game::Game() { Setup(); }

inline Game::~Game()
{
    children.clear();
    childrenBuffer.clear();
    colliders.clear();

    SDL_DestroyWindow(window);
    SDL_DestroyRenderer(renderer);

    ClearAudioCache();

    ClearFontCache();
    CleanupFontInits();

    ClearTextureCache();

    SDL_Quit();
};

inline void Game::AddChildObject(const std::shared_ptr<RenderObject> &child)
{
    child->game = this;

    children.emplace_back(child);
}

template <typename T>
inline auto Game::GetChildrenByType(bool nested)
    -> std::vector<std::shared_ptr<T>>
{
    static_assert(std::is_base_of_v<RenderObject, T>,
                  "T must be derived from RenderObject");

    std::vector<std::shared_ptr<T>> results;

    for (const auto &child : childrenBuffer)
    {
        if (child == nullptr)
        {
            continue;
        }

        if (auto castedChild = std::dynamic_pointer_cast<T>(child))
        {
            results.emplace_back(castedChild);
        }

        if (nested)
        {
            auto childResults = child->GetChildrenByType<T>(nested);

            results.insert(results.end(), childResults.begin(),
                           childResults.end());
        }
    }

    return results;
}

template <typename T>
inline auto Game::GetChildByType(bool nested) -> std::shared_ptr<T>
{
    static_assert(std::is_base_of_v<RenderObject, T>,
                  "T must be derived from RenderObject");

    if (auto childrenBuffer = GetChildrenByType<T>(nested);
        !childrenBuffer.empty())
    {
        return childrenBuffer.front();
    }

    return nullptr;
}

inline auto Game::GetChildCount() -> int { return children.size(); }

inline void Game::AddCollider(const std::shared_ptr<RenderObject> &collider)
{
    colliders.emplace_back(collider);
}

inline auto Game::GetWindow() -> SDL_Window * { return window; }

inline auto Game::GetRenderer() -> SDL_Renderer * { return renderer; }

inline auto Game::GetViewport() const -> const SDL_FRect & { return viewportf; }

inline auto Game::SwitchToFullscreen() -> bool
{
    auto result = SDL_SetWindowFullscreen(window, SDL_TRUE) == 0;

    if (result)
    {
        fullscreen = true;
    }

    return result;
}

inline auto Game::SwitchToWindowedMode() -> bool
{
    auto result = SDL_SetWindowFullscreen(window, SDL_FALSE) == 0;

    if (result)
    {
        SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED);

        fullscreen = false;
    }

    return result;
}

inline auto Game::IsFullscreen() const -> bool { return fullscreen; }

inline auto Game::Setup() -> bool
{
    SDL_SetHint(SDL_HINT_WINDOWS_DPI_SCALING, "1");

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_GAMECONTROLLER) < 0)
    {
        return false;
    }

    if (window != nullptr)
    {
        SDL_DestroyWindow(window);
    }

#ifdef __EMSCRIPTEN__
    window =
        SDL_CreateWindow("", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
                         width, height, SDL_WINDOW_OPENGL);
#else
    window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED, width, height,
                              SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI);
#endif

    SDL_SetWindowResizable(window, SDL_TRUE);

    if (window == nullptr)
    {
        SDL_Log("SDL_CreateWindow %s", SDL_GetError());

        return false;
    }

    if (renderer != nullptr)
    {
        SDL_DestroyRenderer(renderer);
    }

    renderer = SDL_CreateRenderer(
        window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    if (renderer == nullptr)
    {
        SDL_Log("SDL_CreateRenderer %s", SDL_GetError());

        return false;
    }

    SetScreenSize(width, height);

    return true;
}

inline void Game::SetScreenSize(int _width, int _height)
{
    SDL_SetWindowMinimumSize(window, _width, _height);

    SDL_SetWindowSize(window, _width, _height);

    SDL_GL_GetDrawableSize(window, &width, &height);

    viewport.w = width;
    viewport.h = height;
    viewportf.w = static_cast<float>(viewport.w);
    viewportf.h = static_cast<float>(viewport.h);

    SDL_RenderSetScale(renderer, 1.0F, 1.0F);
    SDL_RenderSetLogicalSize(renderer, width, height);

    SDL_RenderSetViewport(renderer, &viewport);

    SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED,
                          SDL_WINDOWPOS_CENTERED);
}

inline void Game::RecalculateScreenSize()
{
    SDL_GL_GetDrawableSize(window, &width, &height);
}

inline void Game::SetTitle(const char *name)
{
    SDL_SetWindowTitle(window, name);
}

inline void Game::SetClearColor(const SDL_Color color)
{
    this->clearColor = color;
}

inline auto Game::GetWidth() const -> int { return viewport.w; }

inline auto Game::GetHeight() const -> int { return viewport.h; }

inline auto Game::HasFocus() const -> bool { return focused; }

inline auto Game::GetElapsedTime() const -> double { return elapsedTime; }

inline auto Game::GetFrameRate() const -> double { return frameRate; }

inline auto Game::GetFPS() const -> double { return fps; }

inline void Game::SetFrameRate(double frameRate)
{
    this->frameRate = frameRate;
}

inline auto Game::GetQuit() const -> bool { return quit; }

inline auto Game::Run() -> int
{
#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop_arg(Game::StaticLoop, this, 0, 1);
#else
    while (!GetQuit())
    {
        Loop();
    }
#endif

    return 0;
}

inline void Game::Loop()
{
    framesThisSecond++;

    auto frameStart = SDL_GetPerformanceCounter();

#ifdef __EMSCRIPTEN__
    if (GetQuit())
    {
        emscripten_cancel_main_loop();
    }
#endif

    HandleInput();

    PopulateChildrenBuffer();

    Update();
    FixedUpdate();

    ResolveCollisions();

    Render();

    DestroyChildObjects();

    auto frameEnd = SDL_GetPerformanceCounter();

    deltaTime = (frameEnd - frameStart) /
                static_cast<double>(SDL_GetPerformanceFrequency());

#ifdef __EMSCRIPTEN__
    deltaTime = std::max(deltaTime, 0.01);
#endif

    float elapsedSeconds = (frameStart - previousFrameStart) /
                           (float)SDL_GetPerformanceFrequency();

    if (elapsedSeconds >= 1)
    {
        fps = (int)(framesThisSecond / elapsedSeconds);
        framesThisSecond = 0;
        previousFrameStart = frameStart;
    }

    SDL_Delay(1);
}

#ifdef __EMSCRIPTEN__
inline void Game::StaticLoop(void *userData)
{
    auto *gameInstance = static_cast<Game *>(userData);

    if (gameInstance != nullptr)
    {
        gameInstance->Loop();
    }
}
#endif

inline void Game::HandleInput()
{
    HandleInputSetup();

    while (SDL_PollEvent(&event) != 0)
    {
        switch (event.type)
        {
        case SDL_QUIT:
            Quit();
            break;

        case SDL_WINDOWEVENT:
            if (event.window.event == SDL_WINDOWEVENT_RESIZED ||
                event.window.event == SDL_WINDOWEVENT_RESTORED ||
                event.window.event == SDL_WINDOWEVENT_MAXIMIZED ||
                event.window.event == SDL_WINDOWEVENT_MINIMIZED)
            {
                RecalculateScreenSize();
            }
            else if (event.window.event == SDL_WINDOWEVENT_FOCUS_LOST)
            {
                focused = false;
            }
            else if (event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED)
            {
                focused = true;
            }
            break;
        default:
            break;
        }

        HandleInputPollEvent(event);
    }
}

inline void Game::PopulateChildrenBuffer()
{
    childrenBuffer = children;

    for (const auto &iter : childrenBuffer)
    {
        auto *child = iter.get();

        if (child != nullptr)
        {
            child->PopulateChildrenBuffer();
        }
    }
}

inline void Game::Update()
{
    elapsedTime += deltaTime;

    for (const auto &iter : childrenBuffer)
    {
        auto *child = iter.get();

        if (child != nullptr && child->IsEnabled())
        {
            child->InternalUpdate(deltaTime);
        }
    }
}

inline void Game::FixedUpdate()
{
    fixedUpdateDeltaTime += deltaTime;

    if (fixedUpdateDeltaTime > fixedFrameTime)
    {
        for (const auto &child : childrenBuffer)
        {
            if (child != nullptr && child->IsEnabled())
            {
                child->InternalFixedUpdate(fixedUpdateDeltaTime);
            }
        }

        fixedUpdateDeltaTime -= fixedFrameTime;
    }
}

inline void Game::Render()
{
    SDL_SetRenderDrawColor(renderer, clearColor.r, clearColor.g, clearColor.b,
                           clearColor.a);

    SDL_RenderClear(renderer);

    sort(childrenBuffer.begin(), childrenBuffer.end(),
         [](const std::shared_ptr<RenderObject> &a,
            const std::shared_ptr<RenderObject> &b) { return a->z < b->z; });

    for (const auto &child : childrenBuffer)
    {
        if (child != nullptr && child->IsEnabled())
        {
            child->Render(renderer);
        }
    }

    SDL_RenderPresent(renderer);
}

inline void Game::ResolveCollisions()
{
    if (colliders.empty())
    {
        return;
    }

    colliders.erase(
        std::remove_if(colliders.begin(), colliders.end(),
                       [](const std::shared_ptr<RenderObject> &collider)
                       {
                           return !collider->IsCollisionEnabled() ||
                                  collider->HasBeenMarkedForDestroy();
                       }),
        colliders.end());

    const auto count = colliders.size();

    if (count <= 1)
    {
        return;
    }

    for (auto i = 0; i < count - 1; i += 1)
    {
        const auto &rectA = colliders[i]->GetTransformedRect();

        for (auto j = i + 1; j < count; j += 1)
        {
            const auto &rectB = colliders[j]->GetTransformedRect();

            if (SDL_HasIntersectionF(&rectA, &rectB) == SDL_TRUE)
            {
                colliders[i]->OnCollision(colliders[j]);
                colliders[j]->OnCollision(colliders[i]);
            }
        }
    }
}

inline void Game::DestroyChildObjects()
{
    for (const auto &child : children)
    {
        if (child != nullptr)
        {
            child->DestroyChildObjects();
        }
    }

    children.erase(std::remove_if(children.begin(), children.end(),
                                  [](const auto &child)
                                  {
                                      if (child->HasBeenMarkedForDestroy())
                                      {
                                          child->OnDestroy();

                                          return true;
                                      }
                                      return false;
                                  }),
                   children.end());
}

inline void Game::Quit() { quit = true; }

#ifdef HANDCRANK_ENGINE_DEBUG
inline void Game::ToggleDebug(bool state) { debug = state; }
inline void Game::ToggleDebug() { debug = !debug; }
inline auto Game::IsDebug() const -> bool { return debug; }
#endif

inline RenderObject::RenderObject()
{
    SetRect(0, 0, DEFAULT_RECT_WIDTH, DEFAULT_RECT_HEIGHT);

    index = ++RenderObject::count;
}

inline RenderObject::RenderObject(float x, float y) : RenderObject()
{
    SetPosition(x, y);
}
inline RenderObject::RenderObject(float x, float y, float w, float h)
    : RenderObject()
{
    SetRect(x, y, w, h);
}

inline RenderObject::~RenderObject()
{
    children.clear();
    childrenBuffer.clear();
}

inline void RenderObject::Enable()
{
    isEnabled = true;

    SetBoundingBoxAsDirty();
}

inline void RenderObject::Disable()
{
    isEnabled = false;

    SetBoundingBoxAsDirty();
}

inline auto RenderObject::IsEnabled() const -> bool { return isEnabled; }

inline auto RenderObject::IsCollisionEnabled() const -> bool
{
    return isCollisionEnabled;
}

inline auto RenderObject::GetIndex() const -> int { return index; }

inline auto RenderObject::GetName() const -> std::string
{
    return name.empty() ? GetClassName() : name;
}
inline void RenderObject::SetName(const std::string &name)
{
    this->name = name;
}

inline auto RenderObject::GetTag() const -> std::string
{
    return tag.empty() ? "untagged" : tag;
}
inline void RenderObject::SetTag(const std::string &tag) { this->tag = tag; }

inline auto RenderObject::GetClassName() const -> std::string
{
    return GetClassNameSimple(*this);
}

inline auto RenderObject::ShowInHierarchy() const -> std::string
{
    if (parent != nullptr)
    {
        return parent->GetName() + " > " + GetName();
    }

    return GetName();
}

inline void
RenderObject::AddChildObject(const std::shared_ptr<RenderObject> &child)
{
    if (game == nullptr)
    {
        throw std::runtime_error(
            "Parent render object has not been mounted yet.");
    }

    child->parent = this;

    child->game = game;

    children.emplace_back(child);
}

template <typename T>
inline auto RenderObject::GetChildrenByType(bool nested)
    -> std::vector<std::shared_ptr<T>>
{
    static_assert(std::is_base_of_v<RenderObject, T>,
                  "T must be derived from RenderObject");

    std::vector<std::shared_ptr<T>> results;

    for (const auto &child : childrenBuffer)
    {
        if (child == nullptr)
        {
            continue;
        }

        if (auto castedChild = std::dynamic_pointer_cast<T>(child))
        {
            results.emplace_back(castedChild);
        }

        if (nested)
        {
            auto childResults = child->GetChildrenByType<T>(nested);

            results.insert(results.end(), childResults.begin(),
                           childResults.end());
        }
    }

    return results;
}

template <typename T>
inline auto RenderObject::GetChildByType(bool nested) -> std::shared_ptr<T>
{
    static_assert(std::is_base_of_v<RenderObject, T>,
                  "T must be derived from RenderObject");

    for (const auto &child : childrenBuffer)
    {
        if (child == nullptr)
        {
            continue;
        }

        if (auto castedChild = std::dynamic_pointer_cast<T>(child))
        {
            return castedChild;
        }

        if (nested)
        {
            auto childResults = child->GetChildByType<T>(nested);

            if (childResults)
            {
                return childResults;
            }
        }
    }

    return nullptr;
}

inline auto RenderObject::GetChildCount() -> int { return children.size(); }

inline void RenderObject::PopulateChildrenBuffer()
{
    childrenBuffer = children;

    for (const auto &iter : childrenBuffer)
    {
        auto *child = iter.get();

        if (child != nullptr)
        {
            child->PopulateChildrenBuffer();
        }
    }
}

inline void RenderObject::Start() {}

inline void RenderObject::Update(double deltaTime) {}

inline void RenderObject::FixedUpdate(double deltaTime) {}

inline void RenderObject::OnMouseOver() {}

inline void RenderObject::OnMouseOut() {}

inline void RenderObject::OnMouseDown() {}

inline void RenderObject::OnMouseUp() {}

inline void
RenderObject::OnCollision(const std::shared_ptr<RenderObject> &other)
{
}

inline void RenderObject::InternalUpdate(double deltaTime)
{
    if (!hasStarted)
    {
        Start();

        hasStarted = true;
    }

    auto transformedRect = GetTransformedRect();

    auto mousePosition = game->GetMousePosition();

    if (SDL_PointInFRect(&mousePosition, &transformedRect) == SDL_TRUE)
    {
        if (game->IsMouseButtonPressed(SDL_BUTTON_LEFT))
        {
            OnMouseDown();

            isInputActive = true;
        }

        if (!isInputHovered)
        {
            OnMouseOver();

            isInputHovered = true;
        }
    }
    else if (isInputHovered)
    {
        OnMouseOut();

        isInputHovered = false;
    }

    if (isInputActive && game->IsMouseButtonReleased(SDL_BUTTON_LEFT))
    {
        OnMouseUp();

        isInputActive = false;
    }

    Update(deltaTime);

    for (const auto &child : childrenBuffer)
    {
        if (child != nullptr && child->IsEnabled())
        {
            child->InternalUpdate(deltaTime);
        }
    }
}

inline void RenderObject::InternalFixedUpdate(double fixedDeltaTime)
{
    FixedUpdate(fixedDeltaTime);

    for (const auto &child : childrenBuffer)
    {
        if (child != nullptr && child->IsEnabled())
        {
            child->InternalFixedUpdate(fixedDeltaTime);
        }
    }
}

inline void RenderObject::OnDestroy() {}

inline auto RenderObject::GetRect() const -> const SDL_FRect & { return rect; }

inline void RenderObject::SetRect(const SDL_FRect &rect)
{
    this->rect = rect;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline void RenderObject::SetRect(float x, float y, float w, float h)
{
    rect.x = x;
    rect.y = y;
    rect.w = w;
    rect.h = h;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline void RenderObject::SetPosition(float x, float y)
{
    rect.x = x;
    rect.y = y;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline void RenderObject::SetDimension(float w, float h)
{
    rect.w = w;
    rect.h = h;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline auto RenderObject::GetAnchor() const -> const RectAnchor &
{
    return anchor;
}
inline void RenderObject::SetAnchor(const RectAnchor anchor)
{
    this->anchor = anchor;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline auto RenderObject::GetScale() const -> float { return scale; }

inline void RenderObject::SetScale(float scale)
{
    this->scale = scale;

    SetTransformedRectAsDirty();
    SetBoundingBoxAsDirty();
}

inline auto RenderObject::GetTransformedRect() -> SDL_FRect
{
    if (transformedRectIsDirty)
    {
        SetTransformedRect();
    }

    return transformedRect;
}

inline void RenderObject::SetTransformedRect()
{
    transformedRect = rect;

    transformedRect.w *= scale;
    transformedRect.h *= scale;

    if ((anchor & RectAnchor::HCENTER) == RectAnchor::HCENTER)
    {
        transformedRect.x -= transformedRect.w / 2;
    }
    else if ((anchor & RectAnchor::RIGHT) == RectAnchor::RIGHT)
    {
        transformedRect.x -= transformedRect.w;
    }

    if ((anchor & RectAnchor::VCENTER) == RectAnchor::VCENTER)
    {
        transformedRect.y -= transformedRect.h / 2;
    }
    else if ((anchor & RectAnchor::BOTTOM) == RectAnchor::BOTTOM)
    {
        transformedRect.y -= transformedRect.h;
    }

    if (parent != nullptr)
    {
        transformedRect.x += parent->GetTransformedRect().x;
        transformedRect.y += parent->GetTransformedRect().y;

        transformedRect.w *= parent->scale;
        transformedRect.h *= parent->scale;
    }

    transformedRectIsDirty = false;
}

inline void RenderObject::SetTransformedRectAsDirty()
{
    if (transformedRectIsDirty)
    {
        return;
    }

    transformedRectIsDirty = true;

    for (const auto &child : children)
    {
        child->SetTransformedRectAsDirty();
    }
}

inline auto RenderObject::GetBoundingBox() -> SDL_FRect
{
    if (boundingBoxIsDirty)
    {
        SetBoundingBox();
    }

    return boundingBox;
}

inline void RenderObject::SetBoundingBox()
{
    boundingBox = GetTransformedRect();

    for (const auto &child : childrenBuffer)
    {
        if (child->IsEnabled())
        {
            const auto childBoundingBox = child->GetBoundingBox();

            float rightExtent = childBoundingBox.x + childBoundingBox.w;
            float bottomExtent = childBoundingBox.y + childBoundingBox.h;
            float currentRight = boundingBox.x + boundingBox.w;
            float currentBottom = boundingBox.y + boundingBox.h;

            boundingBox.x = fminf(boundingBox.x, childBoundingBox.x);
            boundingBox.y = fminf(boundingBox.y, childBoundingBox.y);

            boundingBox.w = fmaxf(currentRight, rightExtent) - boundingBox.x;
            boundingBox.h = fmaxf(currentBottom, bottomExtent) - boundingBox.y;
        }
    }

    boundingBoxIsDirty = false;
}

inline void RenderObject::SetBoundingBoxAsDirty()
{
    if (boundingBoxIsDirty)
    {
        return;
    }

    boundingBoxIsDirty = true;

    if (parent != nullptr)
    {
        parent->SetBoundingBoxAsDirty();
    }
}

inline void RenderObject::EnableCollider()
{
    game->AddCollider(shared_from_this());

    isCollisionEnabled = true;
}
inline void RenderObject::DisableCollider() { isCollisionEnabled = false; }

inline auto RenderObject::CanRender() -> bool
{
    auto boundingBox = GetBoundingBox();

    auto viewport = game->GetViewport();

    return SDL_HasIntersectionF(&boundingBox, &viewport) == SDL_TRUE;
}

inline void RenderObject::Render(SDL_Renderer *renderer)
{
    if (!CanRender())
    {
        return;
    }

    sort(childrenBuffer.begin(), childrenBuffer.end(),
         [](const std::shared_ptr<RenderObject> &a,
            const std::shared_ptr<RenderObject> &b) { return a->z < b->z; });

    for (const auto &child : childrenBuffer)
    {
        if (child != nullptr && child->IsEnabled())
        {
            child->Render(renderer);
        }
    }

#ifdef HANDCRANK_ENGINE_DEBUG
    if (game->IsDebug())
    {
        auto transformedRect = GetTransformedRect();

        if (debugRectTexture == nullptr)
        {
            auto *tempSurface = SDL_CreateRGBSurfaceWithFormat(
                0, 1, 1, 32, SDL_PIXELFORMAT_RGBA32);

            if (tempSurface != nullptr)
            {
                SDL_FillRect(tempSurface, nullptr,
                             SDL_MapRGBA(tempSurface->format, 0, 255, 0, 100));

                debugRectTexture = std::shared_ptr<SDL_Texture>(
                    SDL_CreateTextureFromSurface(renderer, tempSurface),
                    SDL_DestroyTexture);

                SDL_FreeSurface(tempSurface);
            }
        }

        SDL_RenderCopyF(renderer, debugRectTexture.get(), nullptr,
                        &transformedRect);
    }
#endif
}

inline auto RenderObject::CheckCollisionAABB(
    const std::shared_ptr<RenderObject> &otherRenderObject) -> bool
{
    auto thisRect = GetTransformedRect();
    auto otherRect = otherRenderObject->GetTransformedRect();
    return SDL_HasIntersectionF(&thisRect, &otherRect) == SDL_TRUE;
}

inline void RenderObject::DestroyChildObjects()
{
    for (const auto &child : children)
    {
        if (child != nullptr)
        {
            child->DestroyChildObjects();
        }
    }

    children.erase(std::remove_if(children.begin(), children.end(),
                                  [](const auto &child)
                                  {
                                      if (child->HasBeenMarkedForDestroy())
                                      {
                                          child->OnDestroy();

                                          return true;
                                      }
                                      return false;
                                  }),
                   children.end());
}

inline auto RenderObject::HasBeenMarkedForDestroy() const -> bool
{
    return isMarkedForDestroy;
}

inline void RenderObject::Destroy()
{
    isMarkedForDestroy = true;

    DisableCollider();

    for (const auto &child : children)
    {
        if (child != nullptr)
        {
            child->Destroy();
        }
    }
}

} // namespace HandcrankEngine
